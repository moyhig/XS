(define k-gyro-speed  (/   300 1000)) ;; up to  0.6	(NXT: 1.15)
(define k-gyro-angle  (/ 24000 1000)) ;; up to 24.0	(NXT:  7.5)

(define k-ratio-wheel (/ 1250 1000)) ; 1.25 (/ 5.5cm 4.4cm)

(define k-pos   (/  4 1000)) ;; 0.004 (NXT: 0.07)
(define k-speed (/ 70 1000)) ;; 0.07  (NXT: 0.10)

(define package-interval
  (let* ((t-start 0)
	 (t-prev (time))
	 (c-loop  0))    
    (set! init-interval
	  (lambda ()
	    (set! c-loop 0)
	    (set! t-start (time))
	    (set! t-interval (/ 80 10000)))) ; 0.008 (8ms)
    (set! update-interval
	  (lambda () 
	    (set! c-loop (+ c-loop 1))
	    (set! t-interval (/ (- (time) t-prev)
				10000))
	    (set! t-prev (time))))))

(define package-gyro
  (let* ((offset-samples 100)
	 (ema-offset (/ 5 100)) ; (NXT: 0.0005)
	 (gyro-offset 0))
    (set! set-gyro-offset
	  (lambda ()			;; GetGyroOffset => SetGyroOffset
	    (set! gyro-angle 0)
	    (set! gyro-speed 0)
	    (let ((g-sum 0))
	      (let loop ()
		   (set! g-sum (/ 0 1))
		   (let ((g-min  1000)
			 (g-max -1000))
		     (let g-smpl ((n offset-samples))
			  (if (<= n 0)
			      '()
			    (let ((g (gyro 1)))
			      (if (> g g-max)
				  (set! g-max g))
			      (if (< g g-min)
				  (set! g-min g))
			      (set! g-sum (+ g-sum g))
			      (msleep 5)
			      (g-smpl (- n 1)))))
		     (if (> (- g-max g-min) 4)
			 (loop))))
	      (set! gyro-offset (- (/ g-sum offset-samples) 1)))))
    (set! update-gyro-data
	  (lambda ()			;; GetGyroData => UpdateGyroData
	    (let ((gyro-raw (gyro 1)))
	      (set! gyro-offset (+ (* ema-offset gyro-raw)
				   (* (- 1 ema-offset) gyro-offset)))
	      (set! gyro-speed (* 1 (- gyro-raw gyro-offset)))
	      (set! gyro-angle (+ gyro-angle
				  (* gyro-speed t-interval))))))))

(let* ()
  (set-gyro-offset)
  (puts "wake ")
  (sleep 50)
  (init-interval)
  (init-motor-data)
  (update-interval)
  (every :a 8 #t)
  (let loop ()
       (update-interval)
       (update-gyro-data)
       (update-motor-data)
       (let ((p1 (/ (+ (* k-gyro-speed gyro-speed) (* k-gyro-angle gyro-angle))
		    k-ratio-wheel))
	     (p2 (* k-pos   motor-pos))
	     (p3 (* k-speed motor-speed)))
	 (speed :a (ftoi (+ p1 p2 p3)))
	 (speed :c (ftoi (+ p1 p2 p3)))
	 (every :a 8 #t)
	 (loop))))
