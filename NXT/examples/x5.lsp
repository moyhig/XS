(define (ht-balance)
  (cls)
; (rs485-gets)
; (rs485-gets)
; (rs485-gets)
  (puts "wait ")
  (set-gyro-offset)
;  (write (ftoi (set-gyro-offset)))
;  (write-string ":wake in 3s:")
  (puts "wake ")
  (sleep 3000)
  (init-interval)
  (init-motor-data)
  (init-motor-control)
  (catch 'end
    (let* ((t-motor-pos-ok (time))
	   (balance
	    (lambda ()
	      (update-interval)
	      (update-gyro-data)
	      (update-motor-data)
	      (set! motor-pos (- motor-pos
				 (* motor-control-drive t-interval)
				 (/ 50 100))) ;; adjust drift: larger for fwd
	      (let ((power (+ (/ (+ (* k-gyro-speed gyro-speed)
				    (* k-gyro-angle gyro-angle))
				 k-ratio-wheel)
			      (* k-pos   motor-pos)
			      (* k-drive motor-control-drive)
			      (* k-speed motor-speed))))
		(if (and (< (ftoi power) 100) (> (ftoi power) -100))
		    (set! t-motor-pos-ok (time)))
		(let ((steer (get-steer-control power)))
		  (speed :c (car steer))
		  (speed :a (cdr steer)))))))
      (with-watcher (((every :b  200)
		      (or
		      ;(update-motor-control-by-color)
		      ;(update-motor-control-by-eopd)
		      ;(update-motor-control-by-sonar)
		      ;(update-motor-control-by-touch)
		      ;(update-motor-control-by-kbd)
		       (update-motor-control-by-accel)
		       (update-motor-control)))
		     ((every :c 1000)
		      (puts "alive")
		      (if (> (- (time) t-motor-pos-ok) 1500)
			  (throw 'end 0))))
        (let loop ()
	     (balance)
	     (every :a 8 #t) ;; blocking cyclic timer
	     (loop)))))
  (speed :a (speed :c 0))
  (every :b  100 #t) ;; flush semaphore
  (every :c 1000 #t) ;; flush semaphore
  (puts "fail ")
  (ftoi (* t-interval 1000000)))

;(ht-balance)
